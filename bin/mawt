#!/bin/bash

# MAWT: Multi-Agent Worktree Manager
# Usage: mawt [command]

set -e

MAWT_ROOT="$HOME/.mawt"
CONFIG_FILE="$MAWT_ROOT/config"

# Load config
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Defaults
WORKSPACE_DIR="${WORKSPACE_DIR:-$HOME/workspace}"
GITLAB_BASE_URL="${GITLAB_BASE_URL:-https://gitlab.com}"
GITLAB_BASE_URL=${GITLAB_BASE_URL%/} # Ensure no trailing slash

# Dependencies check
check_deps() {
    local deps=("git" "fzf" "jq" "curl")
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            echo "Error: '$dep' is required but not installed."
            exit 1
        fi
    done
}

# Helper: Detect WSL
is_wsl() {
    if [ -f /proc/version ]; then
        grep -q Microsoft /proc/version
    else
        return 1
    fi
}

# ------------------------------------------------------------------
# 1. Repository Selection (Remote + Local)
# ------------------------------------------------------------------
select_repository() {
    local target_repo="$1"

    echo "Fetching project list from GitLab ($GITLAB_BASE_URL)..."
    
    if [ -z "$GITLAB_TOKEN" ]; then
        echo "Error: GITLAB_TOKEN is missing in config."
        echo "Please reinstall or add it to ~/.mawt/config"
        exit 1
    fi

    # API Call
    RESP_FILE=$(mktemp)
    HTTP_CODE=$(curl --silent --write-out "%{http_code}" --output "$RESP_FILE" \
        --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
        "$GITLAB_BASE_URL/api/v4/projects?membership=true&simple=true&per_page=100&order_by=last_activity_at")
    
    RESPONSE=$(cat "$RESP_FILE")
    rm "$RESP_FILE"

    if [ "$HTTP_CODE" -ne 200 ]; then
        echo "Error: Failed to fetch projects (HTTP $HTTP_CODE)."
        echo "Response: $RESPONSE"
        exit 1
    fi

    # Parse JSON
    PROJECTS_FILE=$(mktemp)
    # Format: "path_with_namespace  |  ssh_url  |  http_url"
    echo "$RESPONSE" | jq -r '.[] | "\(.path_with_namespace)\t\(.ssh_url_to_repo)\t\(.http_url_to_repo)"' > "$PROJECTS_FILE"

    # Prepare Display List (Check Local Existence)
    DISPLAY_FILE=$(mktemp)
    
    while IFS=$'\t' read -r path ssh_url http_url; do
        repo_name=$(basename "$path")
        if [ -d "$WORKSPACE_DIR/$repo_name" ]; then
            echo "[Local]  $path" >> "$DISPLAY_FILE"
        else
            echo "[Remote] $path" >> "$DISPLAY_FILE"
        fi
    done < "$PROJECTS_FILE"

    if [ -n "$target_repo" ]; then
        # Direct match for 'init' command
        SELECTED_LINE=$(grep "[[:space:]]${target_repo}$" "$DISPLAY_FILE" | head -n 1)
        if [ -z "$SELECTED_LINE" ]; then
            echo "Error: Repository '$target_repo' not found in fetched list."
            rm "$PROJECTS_FILE" "$DISPLAY_FILE"
            exit 1
        fi
    else
        # FZF Selection
        echo "Select a repository to work on:"
        SELECTED_LINE=$(cat "$DISPLAY_FILE" | fzf --prompt="Repo> " --height=40% --layout=reverse) || true
    fi

    if [ -z "$SELECTED_LINE" ]; then
        echo "No repository selected."
        rm "$PROJECTS_FILE" "$DISPLAY_FILE"
        exit 0
    fi

    # Extract clean path
    # Remove "[Local]  " or "[Remote] " prefix (fixed width + space)
    SELECTED_PATH=$(echo "$SELECTED_LINE" | awk '{print $2}')
    
    # Get URLs from PROJECTS_FILE
    REPO_INFO=$(grep "^${SELECTED_PATH}[[:space:]]" "$PROJECTS_FILE")
    SSH_URL=$(echo "$REPO_INFO" | awk -F'\t' '{print $2}')
    HTTP_URL=$(echo "$REPO_INFO" | awk -F'\t' '{print $3}')

    rm "$PROJECTS_FILE" "$DISPLAY_FILE"

    # Return values via global variables (bash limitation workaround)
    SEL_REPO_NAME=$(basename "$SELECTED_PATH")
    SEL_REPO_PATH="$SELECTED_PATH"
    SEL_SSH_URL="$SSH_URL"
    SEL_HTTP_URL="$HTTP_URL"
}

# ------------------------------------------------------------------
# 2. Ensure Clone (Bare Repo)
# ------------------------------------------------------------------
ensure_cloned() {
    local repo_name="$1"
    local ssh_url="$2"
    local http_url="$3"
    
    local target_dir="$WORKSPACE_DIR/$repo_name"

    # Check if exists
    if [ -d "$target_dir" ]; then
        if [ -d "$target_dir/.bare" ]; then
            return 0 # Already set up
        elif [ -d "$target_dir/.git" ]; then
            echo "Standard repository detected at $target_dir."
            # Only ask interactive confirmation if not in batch/init mode? 
            # For now, keep asking. But 'init' might fail non-interactive here.
            # Assuming 'init' is interactive or just prompts.
            read -p "Convert to Worktree structure? (y/N) " confirm
            if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
                cmd_convert "$target_dir"
                return 0
            else
                echo "Cannot proceed without conversion."
                exit 1
            fi
        else
            echo "Directory $target_dir exists but is not a git repo."
            exit 1
        fi
    fi

    # Determine URL
    # Default to HTTPS unless GIT_PROTOCOL is explicitly set to "ssh"
    if [ "$GIT_PROTOCOL" == "ssh" ]; then
        REPO_URL="$ssh_url"
    else
        REPO_URL="$http_url"
        # Inject token if available for seamless auth
        if [ -n "$GITLAB_TOKEN" ]; then
             # Handle http or https
             local proto="${REPO_URL%%://*}"
             local rest="${REPO_URL#*://}"
             # Use "oauth2" as username for GitLab Token auth
             REPO_URL="${proto}://oauth2:${GITLAB_TOKEN}@${rest}"
        fi
    fi

    # Mask token in logs
    local DISPLAY_URL="$REPO_URL"
    if [ -n "$GITLAB_TOKEN" ]; then
        DISPLAY_URL="${REPO_URL/:$GITLAB_TOKEN@/:***@}"
    fi

    echo "Cloning $repo_name ($DISPLAY_URL)..."
    mkdir -p "$target_dir"
    git clone --bare "$REPO_URL" "$target_dir/.bare"

    # Configure fetch
    cd "$target_dir/.bare"
    git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    
    echo "Repository cloned successfully."
}

# ------------------------------------------------------------------
# 3. Worktree / Branch Selection
# ------------------------------------------------------------------
select_worktree_action() {
    local repo_dir="$1"
    cd "$repo_dir/.bare"

    echo "Fetching latest updates..."
    git fetch --all --prune > /dev/null 2>&1

    # Get Existing Worktrees (exclude bare)
    local wt_list
    wt_list=$(git worktree list | grep -v ".bare" | awk '{print $1 " [" $3 "]"}')

    # Menu Options
    local action
    if [ -z "$wt_list" ]; then
        action="Create New Worktree"
    else
        echo "Choose action:"
        action=$(printf "Create New Worktree\n$wt_list" | fzf --prompt="Action> " --header="Existing Worktrees:") || true
    fi

    if [ -z "$action" ]; then echo "Cancelled."; exit 0; fi

    if [[ "$action" == "Create New Worktree" ]]; then
        create_new_worktree "$repo_dir"
    else
        # Extract path from line "path [branch]"
        EXISTING_PATH=$(echo "$action" | awk '{print $1}')
        TARGET_WORKTREE="$EXISTING_PATH"
    fi
}

create_new_worktree() {
    local repo_dir="$1"
    cd "$repo_dir/.bare"

    # 1. Select Base Branch
    echo "Select Base Branch:"
    # List remote branches, remove 'origin/', strip whitespace
    BASE_BRANCH=$(git branch -r | grep -v 'HEAD' | sed 's/origin\///' | sed 's/^[ \t]*//' | fzf --prompt="Base> ") || true
    
    if [ -z "$BASE_BRANCH" ]; then echo "No base branch selected."; exit 1; fi

    # 2. Input New Branch Name
    read -p "Enter new branch name (Leave empty to use '$BASE_BRANCH'): " NEW_BRANCH
    
    # Use Base Branch if empty
    if [ -z "$NEW_BRANCH" ]; then
        NEW_BRANCH="$BASE_BRANCH"
    fi

    # 3. Create
    TARGET_WORKTREE="$repo_dir/$(basename "$NEW_BRANCH")"
    # If path exists, append random suffix.
    if [ -d "$TARGET_WORKTREE" ]; then
        TARGET_WORKTREE="${TARGET_WORKTREE}_$(date +%s)"
    fi

    echo "Creating worktree for '$NEW_BRANCH'..."

    # Check if branch exists locally
    if git show-ref --verify --quiet "refs/heads/$NEW_BRANCH"; then
        echo "Branch '$NEW_BRANCH' already exists locally."
        # Try to attach.
        if ! git worktree add "$TARGET_WORKTREE" "$NEW_BRANCH" 2>/dev/null; then
             echo "Error: Branch '$NEW_BRANCH' is already checked out in another worktree."
             read -p "Force create? (y/N) " force
             if [[ "$force" == "y" || "$force" == "Y" ]]; then
                 git worktree add -f "$TARGET_WORKTREE" "$NEW_BRANCH"
             else
                 echo "Aborted."
                 exit 1
             fi
        fi
    else
        # Create new branch tracking origin
        git worktree add "$TARGET_WORKTREE" -b "$NEW_BRANCH" "origin/$BASE_BRANCH"
    fi
}

# ------------------------------------------------------------------
# 4. Agent Launch & Auth
# ------------------------------------------------------------------
check_and_setup_auth() {
    local agent="$1"
    local key_var=""
    local key_name=""

    case "$agent" in
        gemini) key_var="GEMINI_API_KEY"; key_name="Gemini API Key" ;;
        claude) key_var="ANTHROPIC_API_KEY"; key_name="Anthropic API Key" ;;
        codex)  key_var="OPENAI_API_KEY"; key_name="OpenAI API Key" ;;
        *) return 0 ;; # No auth needed
    esac

    # Check if variable is set in current environment
    if [ -z "${!key_var}" ]; then
        echo ""
        echo "Authentication check for '$agent'..."
        echo "Choose authentication method:"
        echo "1) API Key (Recommended for automation)"
        echo "2) System/CLI Login (Use existing '$agent' credentials)"
        echo "3) Skip"
        
        read -p "Select [1/2/3]: " choice
        case "$choice" in
            1)
                 read -s -p "Enter $key_name: " input_key
                 echo ""
                 if [ -n "$input_key" ]; then
                    # Append to config
                    echo "" >> "$CONFIG_FILE"
                    echo "export $key_var=\"$input_key\"" >> "$CONFIG_FILE"
                    # Export for current session
                    export "$key_var"="$input_key"
                    echo "Saved to $CONFIG_FILE and exported."
                 else
                    echo "No key entered."
                 fi
                 ;;
            2)
                 echo "Using system credentials. Ensure you have run '$agent auth login'."
                 ;;
            *)
                 echo "Skipping auth setup."
                 ;;
        esac
    fi
}

launch_agent() {
    local wt_path="$1"
    
    if [ ! -d "$wt_path" ]; then
        echo "Error: Worktree path not found: $wt_path"
        exit 1
    fi

    cd "$wt_path"
    echo "Switched to: $(pwd)"

    echo "Select AI Agent:"
    local agents=("gemini" "claude" "codex" "shell")
    AGENT=$(printf "%s\n" "${agents[@]}" | fzf --prompt="Agent> " --height=10 --layout=reverse) || true

    if [ -z "$AGENT" ]; then echo "No agent selected."; exit 0; fi

    # Check Auth before launch
    check_and_setup_auth "$AGENT"

    echo "Launching $AGENT..."
    case "$AGENT" in
        gemini)
            if command -v gemini &> /dev/null; then gemini; else echo "gemini not found"; fi ;;
        claude)
            if command -v claude &> /dev/null; then claude; else echo "claude not found"; fi ;;
        codex)
            if command -v codex &> /dev/null; then codex; else echo "codex not found"; fi ;;
        shell)
            echo "Starting shell..."
            $SHELL
            ;;
    esac
}

# ------------------------------------------------------------------
# Utils
# ------------------------------------------------------------------
cmd_convert() {
    local repo_path="$1"
    echo "Converting '$repo_path'..."
    mv "$repo_path/.git" "$repo_path/.bare"
    cd "$repo_path/.bare"
    git config --bool core.bare true
    local branch_name=$(git symbolic-ref --short HEAD)
    cd ..
    mkdir -p "$branch_name"
    cd ".bare"
    git worktree add "../$branch_name" "$branch_name"
    echo "Converted."
}

cmd_list() {
    echo "Managed Repositories in $WORKSPACE_DIR:"
    if [ ! -d "$WORKSPACE_DIR" ] || [ -z "$(ls -A "$WORKSPACE_DIR" 2>/dev/null)" ]; then
        echo "  No repositories found."
        return
    fi

    for repo in "$WORKSPACE_DIR"/*; do
        if [ -d "$repo/.bare" ]; then
            echo "- $(basename "$repo")"
            cd "$repo/.bare"
            git worktree list | grep -v ".bare" | awk '{print "    - " $3 " (" $1 ")"}'
        fi
    done
}

cmd_uninstall() {
    read -p "Uninstall MAWT? (yes/no): " confirm
    if [ "$confirm" == "yes" ]; then
        rm -rf "$MAWT_ROOT"
        echo "Uninstalled."
    fi
}

# ------------------------------------------------------------------
# Main Dispatch
# ------------------------------------------------------------------
check_deps

case "$1" in
    init)
        if [ -z "$2" ]; then
            echo "Usage: mawt init <group/project>"
            exit 1
        fi
        select_repository "$2"
        ensure_cloned "$SEL_REPO_NAME" "$SEL_SSH_URL" "$SEL_HTTP_URL"
        ;;
    list)
        cmd_list
        ;;
    uninstall)
        cmd_uninstall
        ;;
    help|--help|-h)
        echo "Usage: mawt"
        echo "  (No args)  Start interactive workflow (Select Repo -> Worktree -> Agent)"
        echo "  init <repo> Initialize a specific repository (e.g., mawt init group/project)"
        echo "  list       List managed repositories"
        echo "  uninstall  Remove MAWT"
        ;;
    *)
        # Default Flow
        select_repository ""
        ensure_cloned "$SEL_REPO_NAME" "$SEL_SSH_URL" "$SEL_HTTP_URL"
        select_worktree_action "$WORKSPACE_DIR/$SEL_REPO_NAME"
        launch_agent "$TARGET_WORKTREE"
        ;;
esac
